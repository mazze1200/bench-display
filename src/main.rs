use anyhow::{bail, Result};
use bench_display::wifi;
use core::str;
use embedded_graphics::{
    mono_font::{ascii::FONT_10X20, ascii::FONT_5X8, MonoTextStyle},
    pixelcolor::BinaryColor,
    prelude::*,
    primitives::PrimitiveStyle,
    primitives::{Circle, Line, Rectangle},
    text::{Alignment, Text, TextStyleBuilder},
};
use embedded_svc::{
    http::{client::Client, Method},
    io::Read,
};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::{
        delay::Ets,
        gpio::{AnyIOPin, PinDriver},
        prelude::Peripherals,
        reset,
        spi::{SpiDeviceDriver, SpiDriver, SpiDriverConfig},
    },
    http::client::{Configuration, EspHttpConnection},
};
use ssd1680::color::{Black, Red};
use ssd1680::{
    driver::Ssd1680,
    prelude::{Display, Display2in13, DisplayRotation},
};

use log::{error, info};

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> Result<()> {
    esp_idf_svc::sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;

    info!("Hello, world!");

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let _wifi = match wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    ) {
        Ok(inner) => inner,
        Err(err) => {
            error!(
                "Could not connect to Wi-Fi network: {:?} | {:?}",
                app_config.wifi_ssid, err
            );
            std::thread::sleep(std::time::Duration::from_secs(5));
            reset::restart();
        }
    };

    let spi = peripherals.spi2;

    let rst = PinDriver::output(peripherals.pins.gpio20).unwrap();
    let dc = PinDriver::output(peripherals.pins.gpio10).unwrap();
    let busy = PinDriver::input(peripherals.pins.gpio21).unwrap();
    let mut delay = Ets;

    let sclk = peripherals.pins.gpio6;
    let sdo = peripherals.pins.gpio7;

    let spi = SpiDriver::new(
        spi,
        sclk,
        sdo,
        None::<AnyIOPin>,
        &SpiDriverConfig::default(),
    )
    .unwrap();

    let cs = peripherals.pins.gpio9;

    let mut spi =
        SpiDeviceDriver::new(spi, Some(cs), &esp_idf_svc::hal::spi::config::Config::new()).unwrap();

    // Initialise display controller
    let mut ssd1680 = Ssd1680::new(&mut spi, busy, dc, rst, &mut delay).unwrap();

    // Clear frames on the display driver
    ssd1680.clear_red_frame().unwrap();
    ssd1680.clear_bw_frame().unwrap();

    // Create buffer for black and white
    let mut display_bw = Display2in13::bw();

    display_bw.set_rotation(DisplayRotation::Rotate90);

    let style = MonoTextStyle::new(&FONT_10X20, BinaryColor::Off);
    let _ = Text::with_text_style(
        "Hello",
        Point::new(0, 20),
        style,
        TextStyleBuilder::new().alignment(Alignment::Left).build(),
    )
    .draw(&mut display_bw);

    // draw_rotation_and_rulers(&mut display_bw);

    display_bw.set_rotation(DisplayRotation::Rotate0);

    // outer frame
    Rectangle::new(Point::new(0, 0), Size::new(122, 250))
        .into_styled(PrimitiveStyle::with_stroke(Black, 1))
        .draw(&mut display_bw)
        .unwrap();

    // Rectangle::new(Point::new(60, 60), Size::new(40, 40))
    //     .into_styled(PrimitiveStyle::with_fill(Black))
    //     .draw(&mut display_bw)
    //     .unwrap();

    info!("Send bw frame to display");
    ssd1680.update_bw_frame(display_bw.buffer()).unwrap();

    // // Draw red color
    // let mut display_red = Display2in13::red();

    // Circle::new(Point::new(80, 80), 40)
    //     .into_styled(PrimitiveStyle::with_fill(Red))
    //     .draw(&mut display_red)
    //     .unwrap();

    // // println!("Send red frame to display");
    // ssd1680.update_red_frame(display_red.buffer()).unwrap();

    info!("Update display");
    ssd1680
        .display_frame(&mut esp_idf_svc::hal::delay::FreeRtos)
        .unwrap();

    info!("Done");

    loop {
        std::thread::sleep(std::time::Duration::from_secs(1));
        info!("Hello, world!");
    }
}

fn draw_rotation_and_rulers(display: &mut Display2in13) {
    display.set_rotation(DisplayRotation::Rotate0);
    draw_text(display, "rotation 0", 50, 35, Alignment::Center);
    draw_ruler(display);

    display.set_rotation(DisplayRotation::Rotate90);
    draw_text(display, "rotation 90", 50, 35, Alignment::Center);
    draw_ruler(display);

    display.set_rotation(DisplayRotation::Rotate180);
    draw_text(display, "rotation 180", 50, 35, Alignment::Center);
    draw_ruler(display);

    display.set_rotation(DisplayRotation::Rotate270);
    draw_text(display, "rotation 270", 50, 35, Alignment::Center);
    draw_ruler(display);
}

fn draw_ruler(display: &mut Display2in13) {
    for col in 1..ssd1680::WIDTH {
        if col % 25 == 0 {
            Line::new(Point::new(col as i32, 0), Point::new(col as i32, 10))
                .into_styled(PrimitiveStyle::with_stroke(Black, 1))
                .draw(display)
                .unwrap();
        }

        if col % 50 == 0 {
            let label = col.to_string();
            draw_text(display, &label, col as i32, 20, Alignment::Center);
        }
    }
}

fn draw_text(display: &mut Display2in13, text: &str, x: i32, y: i32, align: Alignment) {
    let style = MonoTextStyle::new(&FONT_5X8, BinaryColor::Off);
    let _ = Text::with_text_style(
        text,
        Point::new(x, y),
        style,
        TextStyleBuilder::new().alignment(align).build(),
    )
    .draw(display);
}
